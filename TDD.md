# Test-Driven Development (TDD)

## TDD ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?

Test-Driven Development (TDD) ‡πÄ‡∏õ‡πá‡∏ô‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏ã‡∏≠‡∏ü‡∏ï‡πå‡πÅ‡∏ß‡∏£‡πå‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡πÇ‡∏î‡∏¢‡∏°‡∏µ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡∏Ñ‡∏∑‡∏≠ **"‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏ó‡∏µ‡πà Fail ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡πÉ‡∏´‡πâ Test ‡∏ú‡πà‡∏≤‡∏ô"**

## ‡∏´‡∏•‡∏±‡∏Å‡∏Å‡∏≤‡∏£ Red-Green-Refactor

TDD ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡∏≤‡∏°‡∏£‡∏≠‡∏ö 3 ‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô:

1. **üî¥ Red**: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏ó‡∏µ‡πà Fail (‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ Code ‡∏ó‡∏µ‡πà‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ)
2. **üü¢ Green**: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Test ‡∏ú‡πà‡∏≤‡∏ô (‡πÉ‡∏ä‡πâ‡∏ß‡∏¥‡∏ò‡∏µ‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
3. **üîµ Refactor**: ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á Code ‡πÉ‡∏´‡πâ‡∏™‡∏∞‡∏≠‡∏≤‡∏î‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡πÑ‡∏°‡πà‡∏ó‡∏≥‡πÉ‡∏´‡πâ Test Fail

## ‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå‡∏Ç‡∏≠‡∏á TDD

- **‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á**: Code ‡∏°‡∏µ Test Coverage ‡∏™‡∏π‡∏á ‡∏•‡∏î Bug
- **Design ‡∏ó‡∏µ‡πà‡∏î‡∏µ**: ‡∏ö‡∏±‡∏á‡∏Ñ‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏Ñ‡∏¥‡∏î Interface ‡∏Å‡πà‡∏≠‡∏ô Implementation
- **‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç**: ‡∏°‡∏µ Test ‡∏Ñ‡∏∏‡πâ‡∏°‡∏Ñ‡∏£‡∏≠‡∏á ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô Code ‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢
- **Documentation**: Test ‡πÄ‡∏õ‡πá‡∏ô Documentation ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ ‚úÖ

### ‡∏Å‡∏≤‡∏£‡∏ó‡∏≥ TDD ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á

```go
// 1. Red: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏ó‡∏µ‡πà Fail ‡∏Å‡πà‡∏≠‡∏ô
// password_validator_test.go
package main

import "testing"

func TestPasswordValidator_ShouldReturnTrueForValidPassword(t *testing.T) {
    validator := PasswordValidator{}
    result := validator.IsValid("mypassword123")
    
    if !result {
        t.Error("IsValid('mypassword123') = false; want true")
    }
}

// 2. Green: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡πÉ‡∏´‡πâ Test ‡∏ú‡πà‡∏≤‡∏ô (‡∏ß‡∏¥‡∏ò‡∏µ‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î)
// password_validator.go
package main

type PasswordValidator struct{}

func (p PasswordValidator) IsValid(password string) bool {
    return true  // Simple implementation to make test pass
}

// 3. Refactor: ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏à‡∏£‡∏¥‡∏á
func (p PasswordValidator) IsValid(password string) bool {
    if len(password) < 8 {
        return false
    }
    if len(password) > 50 {
        return false
    }
    return true
}
```

### ‡∏Ñ‡∏∏‡∏ì‡∏•‡∏±‡∏Å‡∏©‡∏ì‡∏∞‡∏Ç‡∏≠‡∏á Test ‡∏ó‡∏µ‡πà‡∏î‡∏µ

```go
// ‡∏ä‡∏∑‡πà‡∏≠ Test ‡∏ö‡∏≠‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô
func TestUserService_ShouldReturnUserWhenValidEmailProvided(t *testing.T) {
    // Arrange
    userService := NewUserService()
    email := "john@example.com"
    
    // Act
    user, err := userService.FindByEmail(email)
    
    // Assert
    if err != nil {
        t.Errorf("FindByEmail() error = %v", err)
        return
    }
    if user.Email != email {
        t.Errorf("FindByEmail() user.Email = %s; want %s", user.Email, email)
    }
    if user == nil {
        t.Error("FindByEmail() returned nil user")
    }
}
```

## ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏î‡∏µ ‚ùå

### Anti-patterns ‡∏ó‡∏µ‡πà‡∏Ñ‡∏ß‡∏£‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á

#### 1. ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡∏Å‡πà‡∏≠‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test

```go
// ‚ùå ‡∏ú‡∏¥‡∏î: ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡∏Å‡πà‡∏≠‡∏ô
type ProductService struct{}

func (p ProductService) CalculatePrice(basePrice float64, discount float64) float64 {
    return basePrice - (basePrice * discount / 100)
}

func (p ProductService) IsPremiumCustomer(customerID string) bool {
    // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏à‡∏≤‡∏Å Database...
    return customerID == "PREMIUM"
}

// ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏ó‡∏µ‡∏´‡∏•‡∏±‡∏á (‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà TDD)
func TestProductServiceWorks(t *testing.T) {
    service := ProductService{}
    result := service.CalculatePrice(100.0, 10.0)
    if result != 90.0 {
        t.Errorf("CalculatePrice(100, 10) = %f; want 90.0", result)
    }
}
```

#### 2. Test ‡∏ó‡∏µ‡πà‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ

```go
// ‚ùå ‡∏ú‡∏¥‡∏î: Test ‡∏ã‡∏±‡∏ö‡∏ã‡πâ‡∏≠‡∏ô ‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
func TestOrderProcessing(t *testing.T) {
    order := Order{
        Items: []Item{{Name: "Laptop", Price: 1000}},
        CustomerID: "CUST123",
        DiscountCode: "SAVE10",
    }
    
    // ‡∏ó‡∏≥‡∏´‡∏•‡∏≤‡∏¢‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÉ‡∏ô Test ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    validator := OrderValidator{}
    isValid := validator.ValidateOrder(order)
    
    calculator := PriceCalculator{}
    finalPrice := calculator.CalculateTotal(order)
    
    notification := NotificationService{}
    notification.SendConfirmation(order)
    
    // Assert ‡∏´‡∏•‡∏≤‡∏¢‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô
    if !isValid {
        t.Error("Order should be valid")
    }
    if finalPrice != 900.0 {
        t.Errorf("Final price = %f; want 900.0", finalPrice)
    }
    // ‡∏Å‡∏≤‡∏£ test notification ‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö external service
}
```

#### 3. Test ‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö External Dependencies

```go
// ‚ùå ‡∏ú‡∏¥‡∏î: Test ‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö Database ‡∏à‡∏£‡∏¥‡∏á
func TestInventoryService_ShouldUpdateStockAfterPurchase(t *testing.T) {
    product := Product{ID: "LAPTOP001", Stock: 10}
    
    // ‡∏Ç‡∏∂‡πâ‡∏ô‡∏≠‡∏¢‡∏π‡πà‡∏Å‡∏±‡∏ö DB ‡∏à‡∏£‡∏¥‡∏á - ‡πÑ‡∏°‡πà‡∏Ñ‡∏ß‡∏£‡∏ó‡∏≥
    err := realDatabase.UpdateStock(product.ID, 5)
    
    if err != nil {
        t.Errorf("UpdateStock() error = %v", err)
    }
    
    // ‡∏ï‡πâ‡∏≠‡∏á‡πÑ‡∏õ‡πÄ‡∏ä‡πá‡∏Ñ‡πÉ‡∏ô DB ‡∏à‡∏£‡∏¥‡∏á‡∏≠‡∏µ‡∏Å
    updatedProduct, _ := realDatabase.GetProduct(product.ID)
    if updatedProduct.Stock != 5 {
        t.Errorf("Stock = %d; want 5", updatedProduct.Stock)
    }
}
```

## ‡πÄ‡∏Ñ‡∏•‡πá‡∏î‡∏•‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ TDD

### 1. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Test ‡∏ó‡∏µ‡πà‡∏á‡πà‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î

```go
// ‚úÖ ‡∏î‡∏µ: ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏à‡∏≤‡∏Å Happy Path ‡∏á‡πà‡∏≤‡∏¢‡πÜ
func TestEmailValidator_ShouldReturnFalseForEmptyEmail(t *testing.T) {
    validator := EmailValidator{}
    
    result := validator.IsValid("")
    
    if result {
        t.Error("IsValid('') = true; want false")
    }
}
```

### 2. ‡πÉ‡∏ä‡πâ Mock/Stub ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Dependencies

```go
// ‚úÖ ‡∏î‡∏µ: ‡πÉ‡∏ä‡πâ Mock ‡πÅ‡∏ó‡∏ô External Dependencies
type MockPaymentGateway struct {
    ProcessCalled bool
    ProcessParams PaymentRequest
    ProcessResult PaymentResponse
}

func (m *MockPaymentGateway) ProcessPayment(req PaymentRequest) (PaymentResponse, error) {
    m.ProcessCalled = true
    m.ProcessParams = req
    return m.ProcessResult, nil
}

func TestOrderService_ShouldProcessPaymentWhenOrderCreated(t *testing.T) {
    mockPayment := &MockPaymentGateway{
        ProcessResult: PaymentResponse{TransactionID: "TXN123", Status: "SUCCESS"},
    }
    orderService := NewOrderService(mockPayment)
    
    order := Order{TotalAmount: 100.0, CustomerEmail: "john@example.com"}
    result, err := orderService.CreateOrder(order)
    
    if err != nil {
        t.Errorf("CreateOrder() error = %v", err)
    }
    if !mockPayment.ProcessCalled {
        t.Error("Expected ProcessPayment() to be called")
    }
    if mockPayment.ProcessParams.Amount != 100.0 {
        t.Errorf("ProcessPayment() amount = %f; want 100.0", mockPayment.ProcessParams.Amount)
    }
    if result.Status != "COMPLETED" {
        t.Errorf("CreateOrder() status = %s; want COMPLETED", result.Status)
    }
}
```

### 3. Test One Thing at a Time

```go
// ‚úÖ ‡∏î‡∏µ: ‡πÅ‡∏¢‡∏Å Test ‡πÅ‡∏ï‡πà‡∏•‡∏∞ Case
func TestLoginValidator_ShouldReturnTrueForValidCredentials(t *testing.T) {
    validator := LoginValidator{}
    
    result := validator.IsValidUsername("john_doe")
    
    if !result {
        t.Error("IsValidUsername('john_doe') = false; want true")
    }
}

func TestLoginValidator_ShouldReturnFalseForShortUsername(t *testing.T) {
    validator := LoginValidator{}
    
    result := validator.IsValidUsername("ab")
    
    if result {
        t.Error("IsValidUsername('ab') = true; want false")
    }
}

func TestLoginValidator_ShouldReturnFalseForUsernameWithSpecialChars(t *testing.T) {
    validator := LoginValidator{}
    
    result := validator.IsValidUsername("user@name")
    
    if result {
        t.Error("IsValidUsername('user@name') = true; want false")
    }
}
```

## ‡∏™‡∏£‡∏∏‡∏õ

TDD ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÅ‡∏Ñ‡πà‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡πÅ‡∏ï‡πà‡πÄ‡∏õ‡πá‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ß‡∏¥‡∏ò‡∏µ‡∏Ñ‡∏¥‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤ Software ‡πÉ‡∏´‡πâ‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢:

- **‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Test ‡∏Å‡πà‡∏≠‡∏ô‡πÄ‡∏™‡∏°‡∏≠** (Red-Green-Refactor)
- **Test ‡∏ï‡πâ‡∏≠‡∏á‡∏á‡πà‡∏≤‡∏¢ ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¥‡∏™‡∏£‡∏∞**
- **‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ Test ‡∏ú‡πà‡∏≤‡∏ô ‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡πà‡∏≠‡∏¢ Refactor**
- **‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á Complex Test ‡πÅ‡∏•‡∏∞ External Dependencies**

‡∏Å‡∏≤‡∏£‡∏ù‡∏∂‡∏Å‡∏ù‡∏ô TDD ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏™‡∏°‡πà‡∏≥‡πÄ‡∏™‡∏°‡∏≠‡∏à‡∏∞‡∏ó‡∏≥‡πÉ‡∏´‡πâ‡πÄ‡∏£‡∏≤‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô Code ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á ‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤‡∏á‡πà‡∏≤‡∏¢ ‡πÅ‡∏•‡∏∞‡∏°‡∏±‡πà‡∏ô‡πÉ‡∏à‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏î‡πâ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
